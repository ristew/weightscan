<!doctype html>
<html>
  <head>
    <meta charset="utf-8">
    <title>weightscan</title>
    <meta name="description" content="">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <style>
      body { margin: 0; }
      canvas { display: block; }
      .info {
        position: absolute;
        color: white;
        background-color: rgba(0, 0, 0, 0.5);
      }
      #tops-info {
        top: 1.5em;
      }
      #prompt-info {
        top: 3em;
      }
    </style>
    <script type="importmap">
      {
        "imports": {
          "three": "https://unpkg.com/three@0.162.0/build/three.module.js",
          "three/addons/": "https://unpkg.com/three@0.162.0/examples/jsm/"
        }
      }
    </script>
    <script type="module">
      import * as THREE from 'three';
      import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
      const DATA = $$POINTS$$;
      const POINTS = DATA.points;
      const TOPS = DATA.tops;
      const PROMPT = DATA.prompt;
      const NEIGHBORS = DATA.neighbors;
      console.log('neighbors', DATA);
      document.getElementById('prompt-info').textContent = 'prompt: ' + PROMPT;

      const scene = new THREE.Scene();
      scene.fog = new THREE.FogExp2(0x000000, 0.01);
      const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
      const renderer = new THREE.WebGLRenderer();
      renderer.setSize(window.innerWidth, window.innerHeight);
      document.addEventListener('DOMContentLoaded', function() {
        document.body.appendChild(renderer.domElement);
      });
      const controls = new OrbitControls(camera, renderer.domElement);
      camera.position.set(-10, -10, -10);
      camera.lookAt(new THREE.Vector3(0, 0, 0));
      function calculateCenter(frame) {
        const sum = frame.reduce((acc, val) => {
          acc[0] += val[0];
          acc[1] += val[1];
          acc[2] += val[2];
          return acc;
        }, [0, 0, 0]);
        return sum.map(s => s / frame.length);
      }
      const center = calculateCenter(POINTS[0]);
      console.log('center', center);
      controls.target.set(...center);
      controls.update();
      let currentFrameIndex = 0;
      let lastSwitchTime = performance.now();
      const frameDuration = 400; // Frame duration in milliseconds
      let running = true;
      let step = 0;

      const layers = [];
      function frameObjects(frameIdx) {
        const objects = [];
        const frame = POINTS[frameIdx];
        const neighbors = NEIGHBORS[frameIdx];
        const geometry = new THREE.BufferGeometry();
        const positions = new Float32Array(frame.flat());
        geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
        const material = new THREE.PointsMaterial({
          color: 0xDDDDDD,
          size: 0.5,
          sizeAttenuation: true,
          transparent: true,
          opacity: 0.8
        });
        const points = new THREE.Points(geometry, material);
        let maxDist = 0;
        for (const point of neighbors) { // just use second layer
          for (const neighborPair of point) {
            if (neighborPair[1] > maxDist) {
              maxDist = neighborPair[1];
            }
          }
        }
        // objects.push(points);
        for (const pointIdx in frame) {
          for (const neighborPair of neighbors[pointIdx]) {
            const neighborIdx = neighborPair[0];
            const neighborDist = neighborPair[1];
            const neighborWeight = Math.pow(1 - neighborDist / maxDist, 2);
            const neighborPoint = frame[neighborIdx];
            const lineGeometry = new THREE.BufferGeometry().setFromPoints([
              new THREE.Vector3(...frame[pointIdx]),
              new THREE.Vector3(...neighborPoint)
            ]);
            // const distrat = 1.0 - Math.min(0.5 * di.distance / Math.sqrt(averageDist), 1);

            const line = new THREE.Line(lineGeometry, new THREE.LineBasicMaterial({ color: new THREE.Color(neighborWeight, 0.0, 0.2 - 0.2 * neighborWeight) }));
            objects.push(line);
          }
        }
        return objects;
      }
      for (const idx in POINTS) {
        layers.push(frameObjects(idx));
      }

      // Modify animate function to include logic for adding lines
      function animate() {
        requestAnimationFrame(animate);

        const now = performance.now();
        if (running && now - lastSwitchTime > frameDuration) {
          lastSwitchTime = now;

          // Remove the previous frame's points and lines
          while(scene.children.length > 0){
            scene.remove(scene.children[0]);
          }

          for (const obj of layers[currentFrameIndex]) {
            scene.add(obj);
          }
          document.getElementById('frame-info').textContent = `frame ${currentFrameIndex}`;
          document.getElementById('tops-info').textContent = TOPS[currentFrameIndex].map(top => {
            return `'${top[0]}' = ${top[1].toFixed(3)}\n`;
          });

          currentFrameIndex = (currentFrameIndex + 1) % POINTS.length;
          if (step > 0) {
            step = step - 1;
            if (step <= 0) {
              running = false;
            }
          } else if (currentFrameIndex === 0) {
            running = false;
            setTimeout(() => { running = true; }, 2000);
          }
        }
        controls.target.set(...center);
        controls.update();
        renderer.render(scene, camera);
      }

      document.addEventListener('keydown', function (e) {
        if (e.key === ' ') {
          running = !running;
        }
        if (e.key === '[') {
          currentFrameIndex = currentFrameIndex - 2;
          if (currentFrameIndex < 0) {
            currentFrameIndex = POINTS.length + currentFrameIndex;
          }
          step = 1;
          running = true;
        }
        if (e.key === ']') {
          step = 1;
          running = true;
        }
      });

      animate();
    </script>
  </head>
  <body>
    <div id="frame-info" class="info"></div>
    <div id="tops-info" class="info"></div>
    <div id="prompt-info" class="info"></div>
  </body>
</html>
