<!doctype html>
<html>
  <head>
    <meta charset="utf-8">
    <title>weightscan</title>
    <meta name="description" content="">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <style>
      body { margin: 0; }
      canvas { display: block; }
      .info {
        position: absolute;
        color: white;
        background-color: rgba(0, 0, 0, 0.5);
      }
      #tops-info {
        top: 1.5em;
      }
      #prompt-info {
        top: 3em;
      }
    </style>
    <script type="importmap">
      {
        "imports": {
          "three": "https://unpkg.com/three@0.162.0/build/three.module.js",
          "three/addons/": "https://unpkg.com/three@0.162.0/examples/jsm/"
        }
      }
    </script>
    <script type="module">
      import * as THREE from 'three';
      import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
      const DATA = $$POINTS$$;
      const POINTS = DATA.points;
      const TOPS = DATA.tops;
      const PROMPT = DATA.prompt;
      const NEIGHBORS = DATA.neighbors;
      const META = [];
      console.log('neighbors', DATA);
      document.getElementById('prompt-info').textContent = 'prompt: ' + PROMPT;

      const scene = new THREE.Scene();
      scene.fog = new THREE.FogExp2(0x000000, 0.01);
      const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
      const renderer = new THREE.WebGLRenderer();
      renderer.setSize(window.innerWidth, window.innerHeight);
      document.addEventListener('DOMContentLoaded', function() {
        document.body.appendChild(renderer.domElement);
      });
      const controls = new OrbitControls(camera, renderer.domElement);
      camera.position.set(-10, -10, -10);
      camera.lookAt(new THREE.Vector3(0, 0, 0));
      function calculateCenter(layer) {
        const sum = layer.reduce((acc, token) => {
          token.forEach(val => {
            acc[0] += val[0];
            acc[1] += val[1];
            acc[2] += val[2];
          });
          return acc;
        }, [0, 0, 0]);
        const totalPoints = layer.reduce((sum, token) => sum + token.length, 0);
        return sum.map(s => s / totalPoints);
      }
      const center = calculateCenter(POINTS[0]);
      console.log('center', center);
      controls.target.set(...center);
      controls.update();
      let currentLayerIndex = 0;
      let lastSwitchTime = performance.now();
      const frameDuration = 150; // Frame duration in milliseconds
      let running = true;
      let step = 0;

      const layers = [];

      function calculateDistance(p1, p2) {
        return Math.sqrt((p1[0] - p2[0]) ** 2 + (p1[1] - p2[1]) ** 2 + (p1[2] - p2[2]) ** 2);
      }

      function add(p1, p2) {
        return [p1[0] + p2[0], p1[1] + p2[1], p1[2] + p2[2]];
      }

      function sub(p1, p2) {
        return [p1[0] - p2[0], p1[1] - p2[1], p1[2] - p2[2]];
      }

      function mulConst(p1, q) {
        return [p1[0] * q, p1[1] * q, p1[2] * q];
      }

      function divConst(p1, q) {
        return [p1[0] / q, p1[1] / q, p1[2] / q];
      }

      // Generate a color based on the token index
      function getTokenColor(tokenIndex) {
        const hue = (tokenIndex * 0.618033988749895) % 1; // Golden ratio distribution
        return new THREE.Color().setHSL(hue, 0.5, 0.5);
      }

      function neighborLine(layerIdx, tokenIdx, pointIdx, neighborPairIdx) {
        const layer = POINTS[layerIdx];
        const neighbors = NEIGHBORS[layerIdx][tokenIdx];
        const neighborPair = neighbors[pointIdx][neighborPairIdx];
        const neighborIdx = neighborPair[0];
        const point = layer[tokenIdx][pointIdx];
        const neighborPointRaw = layer[tokenIdx][neighborIdx];

        const direction = sub(neighborPointRaw, point);
        const magnitude = Math.sqrt(direction[0] ** 2 + direction[1] ** 2 + direction[2] ** 2);
        const unitVector = divConst(direction, magnitude);
        const neighborPoint = add(point, mulConst(unitVector, 0.07));

        const color = getTokenColor(tokenIdx);
        return {
          color,
          point,
          neighborPoint,
        };
      }
      const EDGES = {};
      const LINES = [];

      function frameObjects(layerIdx) {
        const objects = [];
        const layer = POINTS[layerIdx];
        const layerNeighbors = NEIGHBORS[layerIdx];
        EDGES[layerIdx] = [];
        META[layerIdx] = {};
        const geometry = new THREE.BufferGeometry();
        const positions = new Float32Array(layer.flat(2));
        geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
        const material = new THREE.PointsMaterial({
          color: 0xDDDDDD,
          size: 0.5,
          sizeAttenuation: true,
          transparent: true,
          opacity: 0.8
        });
        const points = new THREE.Points(geometry, material);

        let lineIdx = 0;
        for (const tokenIdx in layer) {
          for (const pointIdx in layer[tokenIdx]) {
            for (const neighborPairIdx in layerNeighbors[tokenIdx][pointIdx]) {
              const edge = {
                lineIdx,
                tokenIdx,
                pointIdx,
                neighborPairIdx,
              };
              EDGES[layerIdx].push(edge);
              lineIdx++;
            }
          }
        }
        return objects;
      }
      for (const idx in POINTS) {
        layers.push(frameObjects(idx));
      }

      for (const tokenIdx in POINTS[0]) {
        for (const pointIdx in POINTS[0][tokenIdx]) {
          for (const neighborPairIdx in NEIGHBORS[0][tokenIdx][pointIdx]) {
            const { color, point, neighborPoint } = neighborLine(0, tokenIdx, pointIdx, neighborPairIdx);
            const lineGeometry = new THREE.BufferGeometry().setFromPoints([
              new THREE.Vector3(...point),
              new THREE.Vector3(...neighborPoint)
            ]);

            const material = new THREE.LineBasicMaterial({ color });
            const line = new THREE.Line(lineGeometry, material);
            LINES.push({ line, material });
            scene.add(line);
          }
        }
      }

      function animate() {
        requestAnimationFrame(animate);

        const now = performance.now();
        if (running && now - lastSwitchTime > frameDuration) {
          lastSwitchTime = now;

          for (const edge of EDGES[currentLayerIndex]) {
            const { color, point, neighborPoint } = neighborLine(currentLayerIndex, edge.tokenIdx, edge.pointIdx, edge.neighborPairIdx);
            const { line, material } = LINES[edge.lineIdx];
            line.geometry.attributes.position.setXYZ(0, ...point);
            line.geometry.attributes.position.setXYZ(1, ...neighborPoint);
            line.geometry.attributes.position.needsUpdate = true;
            material.color.set(color);
          }

          document.getElementById('frame-info').textContent = `layer ${currentLayerIndex}`;
          document.getElementById('tops-info').textContent = TOPS[currentLayerIndex].map(top => {
            return `'${top[0]}' = ${top[1].toFixed(3)}\n`;
          });

          currentLayerIndex = (currentLayerIndex + 1) % POINTS.length;

          if (step > 0) {
            step = step - 1;
            if (step <= 0) {
              running = false;
            }
          } else if (currentLayerIndex === 0) {
            running = false;
            setTimeout(() => { running = true; }, frameDuration * 4);
          }
        }
        controls.target.set(...center);
        controls.update();
        renderer.render(scene, camera);
      }

      document.addEventListener('keydown', function (e) {
        if (e.key === ' ') {
          running = !running;
        }
        if (e.key === '[') {
          currentLayerIndex = currentLayerIndex - 2;
          if (currentLayerIndex < 0) {
            currentLayerIndex = POINTS.length + currentLayerIndex;
          }
          step = 1;
          running = true;
        }
        if (e.key === ']') {
          step = 1;
          running = true;
        }
      });

      animate();
    </script>
  </head>
  <body>
    <div id="frame-info" class="info"></div>
    <div id="tops-info" class="info"></div>
    <div id="prompt-info" class="info"></div>
  </body>
</html>
